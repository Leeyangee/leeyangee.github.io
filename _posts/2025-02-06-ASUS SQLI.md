---
title: ASUS Series-Router SQLi in libbwdpi_sql.so
published: true
---

好长一段时间没更新关于实战的内容了，这段时间一直在钻研 kernel 的知识，还是需要拾起一下老本行. 

在上周发现 ASUS 某系列路由中的某个动态链接库的函数 api 存在 SQL injection 漏洞，并且观测到该漏洞在某个系列中至少已经存在了六年之久，因此想将该漏洞作为专门的对于 lib 安全的文章.

目前已经发现 GT-AC 路由系列的 web api 中基于该库造成的远程 Authenticated SQLi(RCE in specified situation when user turns on a specific debugging mode)

# [](#header-3)A report on the ASUS Routers Vuls in /usr/lib/libbwdpi_sql.so sqlite_Stat_hook caused SQL Injection in multiple series(Or even RCE in specified situation)

Vulnerability Product: GT-AC5300、GT-AC2900、specified versions in GT-AX and other versions that have not yet been discovered  
Vulnerability Test Firmware Version: GT-AC5300_3.0.0.4_386_51569-g9ee6a79_ubi.w (latest)  
Vulnerability type: SQL Injection(Or even RCE in specified situation)  
Vulnerability Authentication Requirement: Low privilege  

There is a SQL Injection in ASUS specified lib `/usr/lib/libbwdpi_sql.so`. When an attacker has a low privilege account of the remote router system, the attacker could trigger SQL injection through the lib api: `/usr/lib/libbwdpi_sql.so`.`sqlite_Stat_hook`(On the GT-AC5300 the remote attacker calling path is `/usr/sbin/httpd`.`appGet.cgi`.`bwdpi_appStat` -> `/usr/lib/libbwdpi_sql.so`.`sqlite_Stat_hook`), and even cause RCE in specified situation

| Contents |
|--------|
| [bin re & lib re](#bin-re-and-lib-re) |
| [firmware re(Take the GT-AC5300 as an example)](#real-firmware-re) |
| [harm](#harm) |
| [info](#info) |

## [](#header-3)bin re and lib re:

Some ASUS router firmwares are ubifs (UBI file system) file systems. For example, the following example is GT-AC5300_3.0.0.4_386_51569-g9ee6a79_ubi.w. You only need to install ubireader and binwalk to easily extract the firmware file system. I will not go into details.  

Next, let's focus on `libbwdpi_sql.so`. The basic information about the library is as follows

```
ELF 头：
  Magic：  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              DYN (共享目标文件)
  系统架构:                          ARM
  版本:                              0x1
  入口点地址：              0xe5c
  程序头起点：              52 (bytes into file)
  Start of section headers:          23640 (bytes into file)
  标志：             0x5000202, Version5 EABI, soft-float ABI, <unknown>
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         4
  Size of section headers:           40 (bytes)
  Number of section headers:         24
  Section header string table index: 23
```

I will not go into details about the discovery process of the libbwdpi_sql.so. You can see that the call stack is as follows: `libbwdpi_sql.so` is essentially the function interface of `libsqlite3.so.0.8.6`

```
/usr/lib/libbwdpi_sql.so        sqlite_Stat_hook
/usr/lib/libbwdpi_sql.so        j_bwdpi_appStat
/usr/lib/libbwdpi_sql.so        bwdpi_appStat
/usr/lib/libbwdpi_sql.so        j_sql_get_table
/usr/lib/libsqlite3.so.0.8.6    sqlite3_get_table
...
```

let's just directly focus on the `sqlite_Stat_hook` in `/usr/lib/libbwdpi_sql.so`, you can find that the param `client` just was simply formatted into `where` without any further filter when `client != "all"` is true. (the following Figure 3).  

![asus](/image/asus_sql/3.png)  
`Figure 3`  

And if `v13 != 0` is true, it means `a1 == 0 && _IF_mode_e_detail_then_0` is true.  
`IF_mode_e_detail_then_0 = _IF_mode_e_detail_then_0 = strcmp(mode, "detail")` is true.  
so `mode != "detail" && a1 == 0`  

and where is the `a1` comes from? `a1` is actually the first parameter of the function `sqlite_Stat_hook`

```c
int __fastcall sqlite_Stat_hook(int a1, const char *client, const char *mode, unsigned int dura, const char *date, _DWORD *a6, FILE *a7);
```

But don't worry, in most cases, the first parameter of the router firmware calling this function is 0, as shown in the example GT-AC5300 I will give below

![asus](/image/asus_sql/8.png)  

Let's focus on the most important parameter `where`. what happend to `where` ? You can see that when `mode == "hour" && dura == 24` is true, `where` is called as the third parameter to `j_bwdpi_appStat` (the following Figure 4)

![asus](/image/asus_sql/4.png)  
`Figure 4`  

Then, let's see what happend in `j_bwdpi_appStat`. `j_bwdpi_appStat` call the `bwdpi_appStat` with the original parameters (the following Figure 5)

You can clearly find that when `having != NULL && where[0] != NULL` is true, the `where` is directly formatted into the `sql_query` and the SQL statement is executed without any filtering, resulting in SQL injection vulnerability (the following Figure 6)

![asus](/image/asus_sql/5.png)  
`Figure 5`  

![asus](/image/asus_sql/6.png)  
`Figure 6`  

if `/tmp/BWSQL_LOG` exists, the `sql_query` will be formatted into command and executed directly, causing RCE (the following Figure 7)

![asus](/image/asus_sql/7.png)  
`Figure 7`  

But it is difficult to make `/tmp/BWQL_LOG` exist, so no further discussion will be made here

After investigation, it was found that the injection vulnerability of the SQL library has existed for at least six years, The following is a search for the possible source code of the same dynamic link library, which was pulled by a user on GitHub six years ago. It clearly shows that the splicing vulnerability has existed for at least six years.

[https://github.com/smx-smx/bcm63138/blob/efd289adf8f0ea2b6c618dc7a427eb37026fc4e1/package/asus_bwdpi_source/src/asus_sql/sqlite_stat.c#L226](https://github.com/smx-smx/bcm63138/blob/efd289adf8f0ea2b6c618dc7a427eb37026fc4e1/package/asus_bwdpi_source/src/asus_sql/sqlite_stat.c#L226)

![asus](/image/asus_sql/9.png)  

## [](#header-3)real firmware re:

Firmware download: [GT-AC5300_3.0.0.4_386_51569-g9ee6a79_ubi.w](/image/asus_sql/GT-AC5300_3.0.0.4_386_51569-g9ee6a79_ubi.w)

Firstly let's see the function of web api `bwdpi_appStat` in `/usr/sbin/httpd`, I call it `T_danger_SQL` here. (the following Figure 1)

you can find that here it received GET args from user, Then call `sqlite_Stat_hook` with the `client`, `mode`, `dura`, `date` received from the user as parameters(the following Figure 2), please attention that here is no any filter

In the following steps, you will find that the param `client` is not filtered until the end

![asus](/image/asus_sql/1.png)  
`Figure 1`  

![asus](/image/asus_sql/2.png)  
`Figure 2`  

You can directly inject malicious payload into the where parameter, causing SQL injection or even RCE

## [](#header-3)HARM: 

When an attacker has a low privilege account of the system, the attacker could trigger SQL injection through the `bwdpi_appStat` in `appGet.cgi`, attacker could SQL Inject by blind injection (such as time based injection, boolean based injection), and even cause RCE in specified situation

## [](#header-3)Info


Thursday, Feb 6, 12:36 --------- Send the report to ASUS

Wednesday, Feb 12, 14:53 ----- ASUS has received the vul, and published a patch fix for a specified version(but they did not fix the vulnerability in the lib, only added a filter in the web interface)

discovered by leeya_bug